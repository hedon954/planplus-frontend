
/**
 * @file draw
 * @author yuanzhen
 * @date 2020/02/17
 */
import {
    measureText
} from './util';

import {
    getValidHeight,
    fixColumnData
} from './draw-chart-data';

/**
 * 绘制x轴
 *
 * @param {*} originPoint 原点
 * @param {*} rangesFormat 坐标轴格式化
 * @param {*} config 配置
 * @param {*} canvasContext canvasContext
 */
export function drawXAixs(
    originPoint,
    rangesFormat,
    config,
    canvasContext
) {
    const {
        xAxis: {
            data: categoryData
        },
        styleConfig: {
            pointLength,
            fontSize,
            fontColor,
            xAxisTextLineHeight
        },
        axisConfig,
        zeroLineIndex
    } = config;
    const {
        startPointX: startX,
        endPointX: endX,
        startPointY: startY,
        endPointY: endY
    } = originPoint;
    const {
        axisPoints,
        eachSpacing
    } = axisConfig;
    const validHeight = getValidHeight(config);
    const validWidth = getValidHeight(config);
    const zeroEndY = startY + zeroLineIndex * validHeight / (rangesFormat.length - 1);
    let spacing = config.xAxis.type === 'value'
        ? validWidth / (rangesFormat.length - 1)
        : eachSpacing;
    const datas = config.xAxis.type === 'value'
        ? rangesFormat
        : axisPoints;

    canvasContext.beginPath();
    canvasContext.setStrokeStyle('#d8d8d8');
    canvasContext.setLineWidth(1);
    canvasContext.setFontSize(fontSize);
    if (datas && datas.length > 0) {
        datas.forEach((item, index) => {
            if (config.xAxis.type === 'value') {
                let pos = startX + spacing * index;
                if (zeroLineIndex === index) {
                    config.baseAxis = pos;
                }
                canvasContext.setTextAlign('center');
                canvasContext.setFillStyle('#8c8c8c');
                canvasContext.fillText(String(item), pos, endY + xAxisTextLineHeight);
            }
            else {
                // 设置x坐标
                if (index !== axisPoints.length - 1 || index !== 0) {
                    canvasContext.moveTo(item, zeroEndY - pointLength);
                    canvasContext.lineTo(item, zeroEndY);
                }
                if (index < categoryData.length) {
                    canvasContext.setFillStyle(fontColor);
                    let text = categoryData[index];
                    let textWidth = measureText(text) + 6;
                    let offset = (spacing - textWidth) / 2;
                    canvasContext.setFillStyle('#8c8c8c');
                    canvasContext.fillText(text, item + offset, endY + xAxisTextLineHeight);
                }
            }
        });
    }
    if (config.xAxis.type === 'value') {
        canvasContext.moveTo(startX, endY);
        canvasContext.lineTo(endX, endY);
    }
    else {
        canvasContext.moveTo(startX, zeroEndY);
        canvasContext.lineTo(endX, zeroEndY);
    }
    canvasContext.closePath();
    canvasContext.stroke();
}

/**
 * 绘制y轴
 *
 * @param {*} originPoint 原点
 * @param {*} rangesFormat 坐标轴格式化
 * @param {*} config 配置
 * @param {*} canvasContext canvasContext
 */
export function drawYAxis(
    originPoint,
    rangesFormat,
    config,
    canvasContext
) {
    const {
        yAxis: {
            data: categoryData
        },
        styleConfig: {
            fontSize,
            yAxisTextWidth,
            padding,
            pointLength
        },
        zeroLineIndex,
        axisConfig
    } = config;
    let {
        axisPoints = [],
        eachSpacing
    } = axisConfig;
    const {
        startPointX: startX,
        startPointY: startY,
        endPointY: endY
    } = originPoint;
    let validHeight = getValidHeight(config);
    const zeroEndX = startX + zeroLineIndex * validHeight / (rangesFormat.length - 1);
    let spacing = config.xAxis.type === 'value'
        ? eachSpacing
        : validHeight / (rangesFormat.length - 1);
    const datas = config.xAxis.type === 'value'
        ? axisPoints
        : rangesFormat;

    canvasContext.setLineWidth(1);
    canvasContext.setStrokeStyle('#d8d8d8');
    canvasContext.setFontSize(fontSize);
    canvasContext.setTextAlign('right');
    if (datas.length > 0) {
        datas.forEach((item, index) => {
            if (config.xAxis.type === 'value') {
                if (index !== datas.length - 1 || index !== 0) {
                    canvasContext.moveTo(zeroEndX, item);
                    canvasContext.lineTo(zeroEndX - pointLength, item);
                }
                // 设置文字 Todo @yuanzhen: 需要处理下对象和数组
                if (index === axisPoints.length - 1) {
                    return;
                }
                let text = categoryData[categoryData.length - 1 - index];
                let offset = spacing / 2;
                canvasContext.setFillStyle('#8c8c8c');
                canvasContext.fillText(text, startX - 4, item + offset);
            }
            else {
                let pos = startY + spacing * index;
                if (zeroLineIndex === index) {
                    config.baseAxis = pos;
                }
                canvasContext.moveTo(startX, pos);
                canvasContext.lineTo(startX + 6, pos);
                canvasContext.save();
                canvasContext.setFillStyle('#8c8c8c');
                canvasContext.fillText(String(item), yAxisTextWidth + padding - 8, pos + fontSize / 2);
            }
        });
    }

    if (config.xAxis.type === 'value') {
        canvasContext.moveTo(zeroEndX, startY);
        canvasContext.lineTo(zeroEndX, endY);
    }
    else {
        canvasContext.moveTo(startX, startY);
        canvasContext.lineTo(startX, endY);
    }
    canvasContext.stroke();
}

/**
 * 绘制坐标轴网格
 *
 * @param {*} originPoint 原点
 * @param {*} rangesFormat 范围
 * @param {*} config 配置
 * @param {*} canvasContext canvasContext
 */
export function drawAxisGrid(originPoint, rangesFormat, config, canvasContext) {
    const {
        startPointX: startX,
        endPointX: endX,
        startPointY: startY,
        endPointY: endY
    } = originPoint;
    const {
        zeroLineIndex,
        styleConfig
    } = config;
    let validLength = getValidHeight(config);
    let eachSpacing = validLength / (rangesFormat.length - 1);
    canvasContext.save();
    canvasContext.beginPath();
    canvasContext.setLineWidth(1);
    canvasContext.setStrokeStyle('rgba(51,136,255,.4)');
    rangesFormat.forEach(function (item, index) {
        let pos = 0;
        if (config.xAxis.type === 'value') {
            pos = startX + eachSpacing * index;
            if (zeroLineIndex !== index) {
                canvasContext.setLineDash([4, 4], 2);
                canvasContext.moveTo(pos, startY);
                canvasContext.lineTo(pos, endY);
            }
        }
        else {
            pos = startY + eachSpacing * index;
            if (zeroLineIndex !== index) {
                canvasContext.setLineDash([4, 4], 2);
                canvasContext.moveTo(startX, pos);
                canvasContext.lineTo(endX, pos);
            }
        }
        if (zeroLineIndex === index) {
            styleConfig.baseAxis = pos;
        }
    });
    canvasContext.closePath();
    canvasContext.stroke();
    canvasContext.restore();
}

/**
 * 获取每条series数据点的坐标
 *
 * @param {*} data 数据
 * @param {*} ranges 坐标轴范围
 * @param {*} axisPoints 坐标轴轴点
 * @param {*} eachSpacing 点之间的距离
 * @param {*} config 配置
 * @return {Array<Object>}
 */
function getDataPoints(
    data,
    ranges,
    axisPoints,
    eachSpacing,
    config,
) {
    const {
        styleConfig: {
            padding,
            yAxisTextWidth
        },
        isHorizontal,
        legendHeight
    } = config;
    let startRange = ranges[ranges.length - 1];
    let endRange = ranges[0];
    if (isHorizontal) {
        [startRange, endRange] = [endRange, startRange];
    }
    let points = [];
    let validHeight = getValidHeight(config);
    data.forEach(function (item, index) {
        if (item === null) {
            points.push(null);
        }
        else {
            let height = validHeight * (item - startRange) / (endRange - startRange);
            let point = {
                value: item,
                height
            };
            if (isHorizontal) {
                point.y = axisPoints[index] + Math.round(eachSpacing / 2);
                point.x = validHeight - Math.round(height) + padding + yAxisTextWidth;
            }
            else {
                point.x = axisPoints[index] + Math.round(eachSpacing / 2);
                point.y = validHeight - Math.round(height) + padding + legendHeight;
            }
            points.push(point);
        }
    });
    return points;
}

/**
 * 绘制折线图
 *
 * @param {*} series 折线数据
 * @param {*} ranges y轴取值范围
 * @param {*} config 用户配置
 * @param {*} canvasContext canvasContext
 * @param {*} process 动画进度
 * @return {*}
 */
export function drawLineDataPoints(
    series,
    ranges,
    config,
    canvasContext,
    process
) {
    const {
        styleConfig: {
            colors
        },
        axisConfig
    } = config;
    let {
        axisPoints,
        eachSpacing
    } = axisConfig;
    let calPoints = [];
    series.forEach((eachItem, index) => {
            // 先处理数组的情况 todo by yuanzhen 处理
            let data = eachItem.data;
            if (!axisConfig.linePoints) {
                axisConfig.linePoints = [];
            }
            let points = axisConfig.linePoints[index]
                || (axisConfig.linePoints[index] = getDataPoints(
                    data,
                    ranges,
                    axisPoints,
                    eachSpacing,
                    config
                ));
            calPoints.push(points);
            drawLineDataSinlePoints(points, canvasContext, colors[index], eachItem.smooth, process);
        });
    return {
        axisPoints,
        calPoints,
        eachSpacing
    };
}

/**
 * 绘制柱状图
 *
 * @param {*} series 柱状图数据
 * @param {*} ranges y轴取值范围
 * @param {*} config 用户配置
 * @param {*} canvasContext canvasContext
 * @param {*} process 进度
 * @return {*}
 */
export function drawDataPoints(
    series,
    ranges,
    config,
    canvasContext,
    process
) {

    const {
        axisConfig
    } = config;
    let {
        axisPoints,
        eachSpacing
    } = axisConfig;
    let calPoints = [];
    series.forEach((eachItem, index) => {
        // 先处理数组的情况 todo by yuanzhen 处理
        let data = eachItem.data;
        if (!axisConfig.barPoints) {
            axisConfig.barPoints = [];
        }

        let points = axisConfig.barPoints[index]
            || (axisConfig.barPoints[index] = getDataPoints(
                data,
                ranges,
                axisPoints,
                eachSpacing,
                config
            ));
        calPoints.push(points);
        points = fixColumnData(points, eachSpacing, series.length, index, config);
        drawBarDataSinglePoints(points, canvasContext, series, eachSpacing, index, config, process);
    });
    return {
        axisPoints,
        calPoints,
        eachSpacing
    };
}

/**
 * 折线图
 *
 * @param {Object} points x, y 横纵坐标，value 该点的值
 * @param {*} canvasContext 当前画布
 * @param {*} color 颜色
 * @param {boolean} smooth 是否光滑
 * @param {number} process 进度
 * @return {undefined}
 */
const r = 6; // 折线节点圆点的半径
function drawLineDataSinlePoints(
    points,
    canvasContext,
    color,
    smooth = false,
    process
) {
    let step = 1 / (points.length - 1);
    const currPoint = (process / step + 1) | 0;
    const t = (process - (currPoint - 1) * step) * (1 / step);
    let pre = points[0];
    // 首先起点画个圆
    drawCircle(pre.x, pre.y, color, canvasContext);
    for (let i = 1; i < points.length; i++) {
        const next = points[i];
        canvasContext.beginPath();
        canvasContext.setStrokeStyle(color);
        canvasContext.setLineWidth(2);
        if (!smooth) {
            const {diffX, diffY, startX, startY} = startPoint(pre, next, r);
            canvasContext.moveTo(startX, startY);
            if (i < currPoint) {
                canvasContext.lineTo(next.x, next.y);
                canvasContext.stroke();
                canvasContext.closePath();
                drawCircle(next.x, next.y, color, canvasContext);
            }
            else if (i === currPoint) {
                canvasContext.lineTo(
                    startX + diffX * t,
                    startY + diffY * t
                );
                canvasContext.stroke();
                canvasContext.closePath();
            }
        }
        else {
            canvasContext.moveTo(pre.x, pre.y);
            canvasContext.lineTo(next.x, next.y);
            canvasContext.closePath();
        }
        pre = next;
    }
}

/**
 *
 * 获取折线图节点原点的起始位置
 *
 * @param {*} pre 折线节点
 * @param {*} next 折线节点
 * @param {*} r 半径
 * @return {Object}
 */
function startPoint(pre, next, r) {
    const xLen = next.x - pre.x;
    const yLen = next.y - pre.y;
    const lineLen = Math.sqrt(xLen ** 2 + yLen ** 2);
    return {
        diffX: xLen,
        diffY: yLen,
        startX: pre.x + xLen / lineLen * r,
        startY: pre.y + yLen / lineLen * r
    };
}

/**
 *
 * 绘制折线图节点圆点
 *
 * @param {*} x 圆点起始x
 * @param {*} y 圆点起始y
 * @param {*} color 圆点色值
 * @param {*} canvasContext 上下文
 */
function drawCircle(x, y, color, canvasContext) {
    canvasContext.save();
    canvasContext.beginPath();
    canvasContext.moveTo(x + r, y);
    canvasContext.setFillStyle('#FFFFFF');
    canvasContext.arc(x, y, r, 0, 2 * Math.PI);
    canvasContext.fill();
    canvasContext.closePath();

    canvasContext.beginPath();
    canvasContext.moveTo(x + r / 2, y);
    canvasContext.setFillStyle(color);
    canvasContext.arc(x, y, r / 2, 0, 2 * Math.PI);
    canvasContext.fill();
    canvasContext.closePath();
    canvasContext.restore();
}

/**
 *
 * 绘制柱状图
 *
 * @param {*} points [{value: 42, height: 280.56, x: 68, y: 91}]
 * @param {*} context 执行上下文
 * @param {*} seriesBar 一个分类里数据总数
 * @param {*} eachSpacing 坐标点间隔
 * @param {*} index 当前index
 * @param {*} config 用户配置
 * @param {*} process 动画进度
 */
function drawBarDataSinglePoints(points, context, seriesBar, eachSpacing, index, config, process = 1) {
    if (config.xAxis.type === 'value') {
        drawBarDataSinglePointsColumn(points, context, seriesBar, eachSpacing, index, config, process);
        return;
    }
    const {
        styleConfig: {
            colors,
            baseAxis,
            padding,
            xAxisTextLineHeight
        },
        canvasHeight
    } = config;
    points.forEach((item, idx) => {
        // 绘制柱状数据图
        context.beginPath();
        context.setFillStyle(colors[index]);
        points.forEach((item, idx) => {
            if (item !== null) {
                let startX = item.x - item.width / 2 + 1;
                const barHeight = item.height - (canvasHeight - xAxisTextLineHeight - padding - baseAxis);
                let height = barHeight * process;
                context.rect(
                    startX,
                    item.y + barHeight,
                    item.width - 2,
                    -height
                );
            }
        });
        context.closePath();
    });
    context.fill();
}

/**
 *
 * 绘制横向柱状图
 *
 * @param {*} points [{value: 42, height: 280.56, x: 68, y: 91}]
 * @param {*} context 执行上下文
 * @param {*} seriesBar 一个分类里数据总数
 * @param {*} eachSpacing 坐标点间隔
 * @param {*} index 当前index
 * @param {*} config 用户配置
 * @param {*} process 动画进度
 */
function drawBarDataSinglePointsColumn(points, context, seriesBar, eachSpacing, index, config, process = 1) {
    const {
        styleConfig: {
            colors,
            padding,
            baseAxis,
            yAxisTextWidth
        }
    } = config;
    points.forEach((item, idx) => {
        // 绘制柱状数据图
        context.beginPath();
        context.setFillStyle(colors[index]);
        points.forEach((item, idx) => {
            if (item !== null) {
                let startY = item.y - item.width / 2 - 1;
                let height = (item.height - (baseAxis - padding - yAxisTextWidth)) * process;
                context.rect(
                    baseAxis,
                    startY,
                    height,
                    item.width - 2
                );
            }
        });
        context.closePath();
    });
    context.fill();

}

/**
 * 绘制饼图
 *
 * @param {Array} series 传入的数据
 * @param {Object} config 配置信息
 * @param {number} diameter 外圈半径
 * @param {number} innerDiameter 内圈半径
 * @param {number} startAngle 起始角度
 * @param {number} process 动画进度(0 - 1)
 * @param {number} highlightIndex 选中的index
 * @return {undefined}
 */
export function drawPieCircle(series, config, diameter, innerDiameter, startAngle, process, highlightIndex) {
    getPieDataPoints(series, process, startAngle, innerDiameter, config);
    let angleList = [];
    if (process === 1) {
        // 获取角度list
        angleList = handleAngleData(series);
    }
    const {
        ctx,
        canvasWidth,
        canvasHeight,
        styleConfig,
        legendHeight
    } = config;
    let centerX = canvasWidth / 2;
    const centerY = (canvasHeight - legendHeight) / 2 + legendHeight;
    ctx.translate(centerX, centerY);
    ctx.rotate(startAngle * Math.PI / 180);
    series.forEach((item, index) => {
        const beginAngle = item.start;
        const endAngle = item.start + 2 * item.proportion * Math.PI;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.setFillStyle(styleConfig.colors[index]);
        if (highlightIndex === index) {
            ctx.arc(0, 0, diameter / 2 + 10, beginAngle + 0.005, endAngle - 0.005);
            ctx.setShadow(0, 0, 17, 'rgba(0, 0, 0, .1)');
        }
        else {
            ctx.arc(0, 0, diameter / 2, beginAngle, endAngle);
            ctx.setShadow(0, 0, 0, 'rgba(0, 0, 0, .1)');
        }
        ctx.closePath();
        ctx.fill();
    });
    if (innerDiameter !== 0) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.setFillStyle('#fff');
        ctx.arc(0, 0, innerDiameter / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
    }
    else {
        if (process === 1) {
            // 扇形时画入每个区域的文字
            drawPieItemText(ctx, startAngle, styleConfig, series, angleList, diameter);
        }
    }
    if (process === 1 && highlightIndex !== undefined && innerDiameter !== 0) {
        // 高亮处理
        drawPieCenterArea(ctx, startAngle, styleConfig, series, highlightIndex);
    }
    ctx.draw();
    // 获取弧度list
    const radianList = handleRadianData(series);
    return {
        center: {
            x: centerX,
            y: centerY
        },
        startAngle,
        diameter,
        innerDiameter,
        series,
        radianList,
        angleList
    };
}

/**
 * 获取每个数据的角度list
 *
 * @param {Array} series 传入的数据
 * @return {Array} 每个数据的起止角度
 */
function handleAngleData(series) {
    return series.map((item, index) => {
        let last = series[0].angle;
        if (index !== series.length - 1) {
            last = series[index + 1].angle;
        }
        if (item.angle < 0 && last > 0) {
            let sub = (180 + item.angle + 180 - last) / 2;
            if ((180 + item.angle - sub) < 0) {
                return last + sub;
            }
            return item.angle - sub;
        }
        return (item.angle + last) / 2;
    });
}

/**
 * 获取每个数据的弧度list
 *
 * @param {Array} series 传入的数据
 * @return {Array} 每个数据的起止弧度
 */
function handleRadianData(series) {
    return series.map((item, index) => {
        let last = series[0].radian;
        if (index !== series.length - 1) {
            last = series[index + 1].radian;
        }
        if (last > 0 && item.radian < 0) {
            return [[-Math.PI, item.radian], [last, Math.PI]];
        }
        return [item.radian, last].sort((a, b) => a - b);
    });
}

/**
 * 绘制选中数据的文案信息
 * @param {Object} ctx  canvas 上下文
 * @param {number} startAngle 起始角度
 * @param {Object} styleConfig 配置信息
 * @param {Array} series 传入的数据
 * @param {number} highlightIndex 选中的index
 * @return {undefined}
 */
function drawPieCenterArea(ctx, startAngle, styleConfig, series, highlightIndex) {
    ctx.rotate(-startAngle * Math.PI / 180);
    ctx.beginPath();
    ctx.setFontSize(styleConfig.fontSize);
    ctx.setFillStyle('#000');
    ctx.setTextBaseline('middle');
    const insertContent = `${series[highlightIndex].name}: ${series[highlightIndex].data}`;
    let text = ctx.measureText(insertContent);
    ctx.fillText(insertContent, -text.width / 2 + 1, 0);
    ctx.closePath();
    ctx.beginPath();
    ctx.setFillStyle(styleConfig.colors[highlightIndex]);
    ctx.arc(-text.width / 2 - 7, 0, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();
}

/**
 * 绘制每片扇形区域的文案
 * @param {Object} ctx  canvas 上下文
 * @param {number} startAngle 起始角度
 * @param {Object} styleConfig 配置信息
 * @param {Array} series 传入的数据
 * @param {Array} angleList 角度list
 * @param {number} diameter 半径
 * @return {undefined}
 */
function drawPieItemText(ctx, startAngle, styleConfig, series, angleList, diameter) {
    ctx.rotate(-startAngle * Math.PI / 180);
    series.forEach((item, index) => {
        ctx.beginPath();
        let startX = diameter / 3 * Math.cos(angleList[index] * Math.PI / 180);
        let startY = -diameter / 3 * Math.sin(angleList[index] * Math.PI / 180);
        ctx.setFontSize(styleConfig.fontSize);
        ctx.setFillStyle('#fff');
        ctx.setTextBaseline('middle');
        const insertContent = series[index].name;
        let text = ctx.measureText(insertContent);
        ctx.fillText(insertContent, -text.width / 2 + startX, startY - 10);
        const nextLine =  series[index].data + '';
        let nextText = ctx.measureText(nextLine);
        ctx.fillText(nextLine, -nextText.width / 2 + startX, startY + 10);
        ctx.fill();
        ctx.closePath();
    });
}

/**
 * 根据进度处理当前数据
 *
 * @param {Array} series 传入的数据
 * @param {number} process 动画进度(0 - 1)
 * @param {number} startAngle 起始角度
 * @return {undefined}
 */
function getPieDataPoints(series, process, startAngle) {
    let count = 0;
    let start = 0;
    let angle = (360 - startAngle) >= 360
        ? (-startAngle > 180
            ? (-startAngle - 360)
            : -startAngle)
        : (360 - startAngle) > 180
            ? (-180 + startAngle)
            : 360 - startAngle;
    series.forEach(function (item) {
        item.data = item.data === null ? 0 : item.data;
        count += item.data;
    });
    series.forEach(function (item) {
        item.data = item.data === null ? 0 : item.data;
        item.proportion = item.data / count * process;
    });
    series.forEach(function (item) {
        item.start = start;
        start += 2 * item.proportion * Math.PI;
        if (process === 1) {
            item.angle = angle;
            item.radian = angle * Math.PI / 180;
            let x = angle - item.proportion * 360;
            angle = x < -180 ? x + 360 : x;
        }
    });
}
