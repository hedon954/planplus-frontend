/**
 * @file draw tooltip
 * @author yuanzhen
 * @date 2020/02/17
 */
import {
    measureText,
    drawRoundRect
} from './util';

// tip内容上下间距
const TIP_PADDING = 15;
// tip高度
const TIP_LINEHEIGHT = 20;
// tip弹层和分割线之间的间距
const TIP_GAP = 10;
// 小icon大小
const ICON_WIDTH = 6;
// icon和文件之间的间距
const ICON_TEXT_GAP = 5;

/**
 *
 * 绘制tooltip
 *
 * @param {*} textList tooltip数据
 * @param {*} originPoint 原点
 * @param {*} config 用户配置
 */
export function drawToolTip(textList, originPoint, config) {
    let {
        tooltip: {
            offset,
            index
        },
        ctxToolTip: context
    } = config;
    let {
        styleConfig: {
            toolTipBackground,
            fontSize,
            padding
        },
        xAxis: {
            data: categoryDataX
        },
        canvasWidth,
        renderType,
        yAxis: {
            data: categoryDataY
        },
        isHorizontal
    } = config;
    const categoryData = isHorizontal
        ? categoryDataY : categoryDataX;
    let textWidth = textList.map(item => measureText(item.text));
    let toolTipWidth = ICON_WIDTH + ICON_TEXT_GAP + Math.max.apply(null, textWidth) + 2 * TIP_PADDING + TIP_GAP;
    let toolTipHeight = TIP_PADDING * 2 + textList.length * TIP_LINEHEIGHT + TIP_LINEHEIGHT;
    let isOverRightBorder = false;
    offset = Object.assign({x: 0, y: 0}, offset);
    let overYOffst = originPoint.endPointY - offset.y;
    offset.y = overYOffst <= toolTipHeight
        ? offset.y - (toolTipHeight - overYOffst) - 8
        : offset.y;
    // if beyond the ri(ght border
    // 弹层左展示
    if (offset.x + TIP_GAP + toolTipWidth > canvasWidth - padding) {
        isOverRightBorder = true;
    }
    if (renderType === 'svg') {
        return {tooltip: {textList, offset}, isOverRightBorder, categoryData: categoryData[index]};
    }
    // draw background rect
    context.beginPath();
    context.save();
    context.setFillStyle(toolTipBackground);
    context.setShadow(0, 0, 10, 'rgba(0,0,0,0.1)');
    drawRoundRect(
        context,
        {
            x: isOverRightBorder ? offset.x - toolTipWidth - TIP_GAP : offset.x + TIP_GAP,
            y: offset.y,
            w: toolTipWidth,
            h: toolTipHeight,
            r: 4,
            color: toolTipBackground
        }
    );
    context.closePath();
    context.fill();

    let startX = isOverRightBorder
            ? offset.x - toolTipWidth - TIP_GAP + TIP_PADDING
            : offset.x + TIP_GAP + TIP_PADDING;
    let startY = offset.y + fontSize * 1.2 + TIP_PADDING - 4;
    context.beginPath();
    context.setFontSize(fontSize * 1.2);
    context.setFillStyle('#000');
    context.fillText(categoryData[index], startX, startY);
    context.stroke();
    context.closePath();
    // draw text之前的icon
    textList.forEach((item, i) => {
        context.beginPath();
        context.setFillStyle(item.color);
        startY += TIP_LINEHEIGHT;
        drawRoundRect(
            context,
            {
                x: startX,
                y: startY,
                w: ICON_WIDTH,
                h: ICON_WIDTH,
                r: 2,
                color: item.color
            }
        );
        context.fill();
        context.closePath();
        context.beginPath();
        context.setFontSize(fontSize);
        context.setFillStyle('#000');
        context.setTextAlign('left');
        context.fillText(item.text, startX + ICON_WIDTH + ICON_TEXT_GAP, startY + fontSize / 2 + 1);
        context.stroke();
        context.closePath();
    });
    context.restore();
    context.draw();
    return true;
}

/**
 * 分割线
 *
 * @param {*} offsetX 当前touch的点
 * @param {*} originPoint 坐标起始点
 * @param {*} context 当前
 */
export function drawToolTipSplitLine(offsetX, originPoint, context) {
    let {startPointY, endPointY} = originPoint;
    context.save();
    context.beginPath();
    context.setStrokeStyle('rgba(51,136,255,.4)');
    context.setLineDash([6, 4], 4);
    context.setLineWidth(1);
    context.moveTo(offsetX, startPointY);
    context.lineTo(offsetX, endPointY);
    context.stroke();
    context.closePath();
    context.restore();
}

/**
 * drawToolTipBarBack(chartData, originPoint, ctxAxis);
 *
 * @param {*} chartData {axisPoints, eachSpacing} 坐标点和其之前的间隔
 * @param {*} originPoint 起始位置点
 * @param {*} height 高度
 * @param {*} index 当前第几个touch index
 * @param {*} isHorizontal 是否是横向的
 * @param {*} context 画板
 */
export function drawToolTipBarBack(
    chartData,
    originPoint,
    height,
    index,
    isHorizontal,
    context
) {
    let {
        axisPoints = {},
        eachSpacing
    } = chartData;
    context.beginPath();
    context.setFillStyle('rgba(0,0,0,.03)');
    if (isHorizontal) {
        context.rect(
            originPoint.startPointX,
            axisPoints[index],
            height,
            eachSpacing
        );
    }
    else {
        context.rect(
            axisPoints[index],
            originPoint.startPointY,
            eachSpacing,
            height
        );
    }
    context.closePath();
    context.fill();
}
