/**
 * @file draw
 * @author yuanzhen
 * @date 2020/07/30
 */
import {Config} from './config';
import {
    drawXAixs,
    drawYAxis,
    drawAxisGrid,
    drawLineDataPoints,
    drawDataPoints,
    drawPieCircle
} from './draw';

import {
    findPieChartCurrentIndex,
    findCurrentIndex,
    getSeriesDataItem,
    getToolTipData,
    getZeroLineIndex,
    getCategoryPoints,
    getOriginPoints,
    getYAxisTextList,
    getValidHeight
} from './draw-chart-data';
import {
    drawLegend,
    calLegendData
} from './draw-chart-legend';
import Animation from './animation';
import {
    drawToolTipSplitLine,
    drawToolTipBarBack,
    drawToolTip
} from './draw-tooltip';
import {
    getDuration
} from './util';

export default class SwanChart {
    constructor(config) {
        this.chartData = {};
        this.config = {
            isHorizontal: config.xAxis.type === 'value',
            ...config,
            ...{
                styleConfig: {
                    ...Config,
                    ...config.styleConfig
                }
            }
        };
        this.init(this.config);
    }
    init(config) {
        this.drawChart(config);
    }

    /**
     *
     * 绘图
     *
     * @param {*} config 用户配置
     */
    drawChart(config) {
        if (!config.ctx) {
            throw new Error('不存在canvas绘图上下文');
        }

        const {
            series,
            animation,
            // 开始角度
            startAngle = -90
        } = config;
        // 获取取值范围
        let ranges;
        let rangesFormat;
        // 获取图表渲染类型
        let type = this.getChartType();
        // 获取动画时长
        let duration = getDuration(animation);
        let originPoint;
        //  直径
        let diameter = 0;
        // 内圈直径
        let innerDiameter = 0;
        // 获取legendList
        let {legendList, legendHeight} = calLegendData(config);
        config.legendHeight = legendHeight;
        if (type !== 'pie') {
            // 获取取值范围
            const yAxisTextList = getYAxisTextList(series, config);
            ranges = yAxisTextList.ranges;
            rangesFormat = yAxisTextList.rangesFormat;
            // let yAxisWidth = getVerticalTextWidth(ranges, config);
            let zeroLineIndex = getZeroLineIndex(ranges);
            config.zeroLineIndex = zeroLineIndex;
            // 获取原点
            originPoint = getOriginPoints(config);
            config.axisConfig = getCategoryPoints(config, originPoint);
            this.chartData = Object.assign({}, {
                type,
                originPoint,
                ranges,
                rangesFormat,
                legendList
            });
            this.animationInstance && this.animationInstance.stop();
            this.drawAxisOnce(
                type,
                originPoint,
                rangesFormat,
                legendList,
                config
            );
        }
        else {
            const {
                radius,
                canvasWidth,
                canvasHeight,
                styleConfig: {pieChartLinePadding},
                legendHeight
            } = config;
            diameter = Math.min(canvasWidth, canvasHeight - legendHeight) - 2 * pieChartLinePadding;
            this.chartData = Object.assign({}, {
                type
            });
            if (Array.isArray(radius)) {
                radius.sort((a, b) => b - a);
                diameter = diameter * radius[0] / 100;
                innerDiameter = diameter * radius[1] / 100;
            }
            this.paramsInfo = {
                series,
                config,
                diameter,
                innerDiameter,
                startAngle
            };
            drawLegend(legendList, config);
        }
        switch (type) {
            case 'line':
                this.animationInstance = new Animation({
                    timing: 'easeIn',
                    duration: duration,
                    onProcess: process => {
                        let {
                            axisPoints,
                            calPoints,
                            eachSpacing
                        } = drawLineDataPoints(
                            series,
                            ranges,
                            config,
                            config.ctx,
                            process
                        );
                        this.chartData.axisPoints = axisPoints;
                        this.chartData.calPoints = calPoints;
                        this.chartData.eachSpacing = eachSpacing;
                        config.ctx.draw('line');
                    }
                });
                break;
            case 'bar':
                this.animationInstance = new Animation({
                    timing: 'easeIn',
                    duration: duration,
                    onProcess: process => {
                        let {
                            axisPoints,
                            calPoints,
                            eachSpacing
                        } = drawDataPoints(
                            series,
                            ranges,
                            config,
                            config.ctx,
                            process
                        );
                        // todo 获取坐标点
                        this.chartData.axisPoints = axisPoints;
                        this.chartData.calPoints = calPoints;
                        this.chartData.eachSpacing = eachSpacing;
                        config.ctx.draw('bar');
                    }
                });
                break;
            case 'pie':
                this.animationInstance = new Animation({
                    timing: 'easeIn',
                    duration,
                    onProcess: process => {
                        this.chartData.pieData = drawPieCircle(
                            series,
                            config,
                            diameter,
                            innerDiameter,
                            startAngle,
                            process
                        );
                    }
                });
                break;
        }
    }

    /**
     *
     * 获取tooltip数据
     *
     * @param {*} e touches对象
     * @return {Obejct}
     */
    showToolTip(e) {
        let type = this.chartData.type;
        if (!['line', 'bar', 'pie'].includes(type)) {
            return false;
        }
        const {
            originPoint,
            rangesFormat,
            legendList
        } = this.chartData;
        let index = this.getCurrentDataIndex(e);
        // 如果不在数据范围内，将原来的 tooltip 隐藏
        const {
            series,
            config,
            diameter,
            innerDiameter,
            startAngle
        } = this.paramsInfo || {};
        if (index <= -1) {
            if (type === 'pie') {
                drawPieCircle(
                    series,
                    config,
                    diameter,
                    innerDiameter,
                    startAngle,
                    1,
                );
            }
            return false;
        }
        if (type !== 'pie') {
            const seriesData = getSeriesDataItem(
                index,
                this.config
            );
            const offset = getToolTipData(
                e,
                index,
                this.chartData.calPoints
            );
            this.config.tooltip = {
                ...this.config.tooltip,
                offset,
                index
            };
            this.config.animation = false;
            this.drawAxisOnce(
                type,
                originPoint,
                rangesFormat,
                legendList,
                this.config
            );
            return drawToolTip(
                seriesData,
                originPoint,
                this.config
            );
        }
        drawPieCircle(
            series,
            config,
            diameter,
            innerDiameter,
            startAngle,
            1,
            index
        );
    }

    /**
     *
     * 获取选中项index
     *
     * @param {*} e touches对象
     * @return {number}
     */
    getCurrentDataIndex(e) {
        let touches = e.touches && e.touches.length ? e.touches : e.changedTouches;
        if (touches && touches.length) {
            let {x, y} = touches[0];
            if (!x || !y) {
                x = touches[0].pageX - e.currentTarget.offsetLeft;
                y = touches[0].pageY - e.currentTarget.offsetTop;
            }
            if (this.chartData.type === 'pie') {
                return findPieChartCurrentIndex({x, y}, this.chartData.pieData);
            }
            else {
                return findCurrentIndex({x, y}, this.chartData.axisPoints, this.config);
            }
        }

        return -1;
    }

    /**
     *
     * 绘制坐标轴， 只在初始化绘制一次
     *
     * @param {*} type 图表类型
     * @param {*} originPoint 坐标轴原点
     * @param {*} rangesFormat 纵坐标取值范围
     * @param {*} legendList 图例list
     * @param {*} config 用户配置
     */
    drawAxisOnce(
        type,
        originPoint,
        rangesFormat,
        legendList,
        config
    ) {
        const {
            ctxAxis,
            styleConfig: {
                toolTipBackground
            },
            tooltip,
            legend,
            isHorizontal
        } = config;

        drawXAixs(
            originPoint,
            rangesFormat,
            config,
            ctxAxis
        );

        drawYAxis(
            originPoint,
            rangesFormat,
            config,
            ctxAxis
        );

        drawAxisGrid(
            originPoint,
            rangesFormat,
            config,
            ctxAxis
        );

        if (legend && legend.show) {
            drawLegend(
                legendList,
                config,
                ctxAxis
            );
        }
        if (tooltip && tooltip.show) {
            if (type === 'line' && tooltip.offset) {
                drawToolTipSplitLine(tooltip.offset.x, originPoint, ctxAxis);
            }
            else if (type === 'bar') {
                let height = getValidHeight(config);
                drawToolTipBarBack(
                    this.chartData,
                    originPoint,
                    height,
                    tooltip.index,
                    isHorizontal,
                    ctxAxis
                );
            }
        }

        ctxAxis.draw('aixs');
    }

    // 获取图表类型
    getChartType() {
        let {
            type,
            series
        } = this.config;
        if (type) {
            return type;
        }

        let computeTypeObject = {};
        series.forEach(item => {
            item.type = item.type || 'line';
            if (!computeTypeObject[item.type]) {
                computeTypeObject[item.type] = item.type;
            }

        });
        if (Object.keys(computeTypeObject).length === 1) {
            return Object.keys(computeTypeObject)[0];
        }

        return 'line';
    }
}
