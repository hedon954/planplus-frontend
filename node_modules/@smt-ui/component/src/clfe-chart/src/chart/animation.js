/**
 * @file 动画
 * @author guozhihao02
*/
const timingFunc = {
    easeIn: pos => Math.pow(pos, 3),
    easeOut: pos => Math.pow((pos - 1), 3) + 1,
    easeInOut: pos => (pos /= 0.5) < 1 ? 0.5 * Math.pow(pos, 3) : 0.5 * (Math.pow((pos - 2), 3) + 2),
    linear: pos => pos
};

export default class Animation {
    constructor(opts) {
        this.init(opts);
    }
    /**
     * 初始化
     * @param {*} opts 动画参数
     */
    init(opts) {
        this.isStop = false;
        const duration = typeof opts.duration === 'undefined' ? 1000 : opts.duration;
        const timing = opts.timing || 'linear';
        let delay = 17;
        let createAnimationFrame = function () {
            if (typeof requestAnimationFrame !== 'undefined') {
                return requestAnimationFrame;
            }
            else if (typeof setTimeout !== 'undefined') {
                return function (step, delay) {
                    setTimeout(function () {
                        let timeStamp = +new Date();
                        step(timeStamp);
                    }, delay);
                };
            }
            return function (step) {
                step(null);
            };
        };
        let animationFrame = createAnimationFrame();
        let startTimeStamp = null;
        let step = function (timestamp) {
            if (timestamp === null || this.isStop === true) {
                opts.onProcess && opts.onProcess(1);
                opts.onAnimationFinish && opts.onAnimationFinish();
                return;
            }
            if (startTimeStamp === null) {
                startTimeStamp = timestamp;
            }
            if (timestamp - startTimeStamp < duration) {
                let process = (timestamp - startTimeStamp) / duration;
                let timingFunction = timingFunc[timing];
                process = timingFunction(process);
                opts.onProcess && opts.onProcess(process);
                animationFrame(step, delay);
            }
            else {
                opts.onProcess && opts.onProcess(1);
                opts.onAnimationFinish && opts.onAnimationFinish();
            }
        };
        step = step.bind(this);
        animationFrame(step, delay);
    }
    // 停止动画
    stop() {
        this.isStop = true;
    }
}
