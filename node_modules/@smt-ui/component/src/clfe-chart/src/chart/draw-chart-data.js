/**
 * @file draw
 * @author yuanzhen
 * @date 2020/09/17
 */
import {
    utils,
    measureText,
    combineData,
    isPlainObject,
    getDataRange
} from './util';

/**
 *
 * 找到当前点击柱图和折线图的index
 *
 * @param {*} currentPoints event.touches对象
 * @param {*} axisPoints series计算节点
 * @param {*} config 用户配置
 * @param {*} offset 点击evnet
 * @return {number} currentIndex 索引
 */
export function findCurrentIndex(currentPoints, axisPoints, config, offset = 0) {
    let currentIndex = -1;
    if (isInExactChartArea(currentPoints, config)) {
        axisPoints.forEach((item, index) => {
            // 区分横向坐标轴
            let currentPoint = config.isHorizontal ? currentPoints.y : currentPoints.x;
            if (currentPoint + offset > item) {
                currentIndex = index;
            }
        });
    }
    return currentIndex;
}

/**
 *
 * 判断当前touches对象是否在画布之内
 *
 * @param {*} currentPoints event.touches对象
 * @param {*} config 用户配置
 * @return {boolean} 点击点是否在画布之内
 */
function isInExactChartArea(currentPoints, config) {
    let {
        styleConfig: {
            padding,
            xAxisTextLineHeight,
            yAxisTextWidth,
            legendHeight
        },
        canvasHeight,
        canvasWidth
    } = config;
    return currentPoints.x < canvasWidth - padding
        && currentPoints.x > padding + yAxisTextWidth
        && currentPoints.y > padding
        && currentPoints.y < canvasHeight - legendHeight - xAxisTextLineHeight;
}

/**
 *
 * 根据用户点击index，整理当前tooltip展示数据
 *
 * @param {*} index 当前点击索引
 * @param {*} config 用户配置
 * @return {Array} 返回tooltip数据
 */
export function getSeriesDataItem(index, config) {
    const {
        series,
        xAxis: {
            data
        }
    } = config;
    let dataFormat = [];
    series.forEach((item, iIndex) => {
        if (item.data[index] !== null && typeof item.data[index] !== 'undefined') {
            let seriesItem = {
                color: config.styleConfig.colors[iIndex],
                name: item.name,
                text: config.format ? config.format(item, data[index]) : `${item.name}: ${item.data[index]}`,
                data: item.data[index]
            };
            dataFormat.push(seriesItem);
        }
    });
    return dataFormat;
}

/**
 *
 * 获取当前tooltip展示数据
 *
 * @param {*} e touches对象
 * @param {*} index 当前点击索引
 * @param {*} calPoints 当前选中的series数据
 * @return {number} offset 点击坐标偏移值
 */
export function getToolTipData(e, index, calPoints) {
    let offset = {
        x: 0,
        y: e.touches[0].y || e.touches[0].clientY
    };
    calPoints.forEach(points => {
        let item = points[index];
        if (item) {
            offset.x = Math.round(item.x);
        }
    });
    return offset;
}

/**
 *
 * 获取纵轴节点文字的最大宽度
 *
 * @param {*} ranges 纵轴坐标分割节点
 * @param {*} config 用户配置
 * @return {number} 纵向分类的字体宽度
 */
export function getVerticalTextWidth(ranges, config) {
    let {
        styleConfig: {
            yAxisTextWidth: yAxisWidth
        },
        styleConfig,
        yAxis,
        isHorizontal
    } = config;
    let dataArray = isHorizontal ? yAxis.data : ranges;
    dataArray.forEach(item => {
        item = !isHorizontal ? utils.toFixed(item, 2) : item;
        yAxisWidth = Math.ceil(Math.max(yAxisWidth, measureText(item)));
    });
    styleConfig.yAxisTextFinalWidth = yAxisWidth;
    return yAxisWidth;
}

/**
 * 根据坐标轴值的范围，获取零线index
 *
 * @param {*} ranges 坐标轴值的范围
 * @return {number} index
 */
export function getZeroLineIndex(ranges) {
    return ranges.indexOf(0) < 0
        ? ranges.length - 1
        : ranges.indexOf(0);
}

/**
 * X轴个点的位置
 *
 * @param {*} config 用户配置
 * @param {*} originPoint 坐标的原点
 * @return {Object}
 */
export function getCategoryPoints(config, originPoint) {
    const {
        xAxis: {
            data: categoryDataX
        },
        yAxis: {
            data: categoryDataY
        },
        styleConfig: {
            padding,
            xAxisTextLineHeight,
            yAxisTextWidth
        },
        isHorizontal,
        legendHeight,
        canvasWidth,
        canvasHeight
    } = config;
    const {
        startPointX: startX,
        endPointX: endX,
        startPointY: startY,
        endPointY: endY
    } = originPoint;

    const categoryData = !isHorizontal
        ? categoryDataX : categoryDataY;

    if (!categoryData) {
        return;
    }
    // 获取类目个数
    let categoryCount = isPlainObject(categoryData)
        ? Object.keys(categoryData).length
        : categoryData.length;

    // 获取实际x坐标轴的宽度
    let spacingValid = !isHorizontal
        ? canvasWidth - padding * 2 - yAxisTextWidth
        : canvasHeight - padding * 2 - xAxisTextLineHeight - legendHeight;
    // 获取每一个坐标的宽度， 依次来设计坐标点
    let eachSpacing = spacingValid / categoryCount;
    // 获取坐标点
    let axisPoints = [];
    const start = !isHorizontal ? startX : startY;
    categoryData.forEach((item, index) => {
        axisPoints.push(start + index * eachSpacing);
    });
    axisPoints.push(!isHorizontal ? endX : endY);
    config.axisConfig = {
        axisPoints,
        eachSpacing
    };
    return config.axisConfig;
}

/**
 *
 * 得出画布纵轴的高度， 画布高度 - 顶部paddding值 - x轴文案展示高度
 * todo: 文案展示高度 需要判断下 如果x轴没有data, xAxisTextLineHeight = 0
 * todo: 计算 yAxisWidth可以直接拿出来处理一次， 缓存起来，by 袁臻
 *
 * @param {*} config 用户配置
 * @return {number}
 */
export function getValidHeight(config) {
    let {
        styleConfig: {
            padding,
            xAxisTextLineHeight,
            yAxisTextWidth
        },
        isHorizontal,
        legendHeight,
        canvasHeight,
        canvasWidth
    } = config;
    // 竖向柱状图和折线图
    if (!isHorizontal) {
        return canvasHeight - padding * 2 - xAxisTextLineHeight - legendHeight;
    }
    // 横向柱状图
    return canvasWidth - padding * 2 - yAxisTextWidth;
}

/**
 * 计算原点
 *
 * @param {*} config 配置
 * @return {Object}
 */
export function getOriginPoints(config) {
    let {
        styleConfig: {
            yAxisTextWidth,
            padding,
            xAxisTextLineHeight
        },
        legendHeight,
        canvasHeight,
        canvasWidth
    } = config;
    return {
        startPointX: padding + yAxisTextWidth,
        endPointX: canvasWidth - padding,
        startPointY: padding + legendHeight,
        endPointY: canvasHeight - xAxisTextLineHeight - padding
    };
}


/**
 * 计算范围
 *
 * @param {*} series 数据
 * @param {*} config 配置
 * @return {Array<number, number>}
 */
export function getYAxisTextList(series, config) {
    const {
        styleConfig: {
            axisSplit,
            scale
        },
        isHorizontal,
        styleConfig
    } = config;
    let originData = combineData(series);
    let formatData = [];
    // remove null from data,
    // 拍平两种数据类型 array[object] | array[string]
    originData.forEach(item => {
        if (item !== null) {
            formatData.push(isPlainObject(item) ? item.value : item);
        }
    });
    let minData = Math.min.apply(this, formatData);
    let maxData = Math.max.apply(this, formatData);
    let {
        minRange,
        interval,
        splitNumber
    } = getDataRange([
        scale && minData >= 0
            ? 0
            : minData,
        scale && maxData <= 0
            ? 0
            : maxData
    ], axisSplit);
    styleConfig.axisNiceSplit = splitNumber;
    let ranges = [];
    let rangesFormat = [];
    for (let i = splitNumber; i >= 0; i--) {
        let item = minRange + interval * i;
        let itemFormat = utils.toFixed(item, 2);
        // todo 对数据进行整理单位
        // itemFormat = opts.yAxis.format ? opts.yAxis.format(Number(itemFormat)) : itemFormat;
        ranges.push(item);
        rangesFormat.push(itemFormat);
    }
    return {
        ranges: isHorizontal ? [...ranges].reverse() : ranges,
        rangesFormat: isHorizontal ? [...rangesFormat].reverse() : rangesFormat
    };
}

/**
 *
 * 找到当前点击饼图的index
 *
 * @param {*} currentPoints event.touches对象
 * @param {*} pieData series计算节点
 * @return {number} currentIndex 索引
 */
export function findPieChartCurrentIndex(currentPoints, pieData) {
    let currentIndex = -1;
    if (isInExactPieChartArea(currentPoints, pieData)) {
        let angle = Math.atan2(pieData.center.y - currentPoints.y, currentPoints.x - pieData.center.x);
        for (let i = 0, len = pieData.radianList.length; i < len; i++) {
            let item = pieData.radianList[i];
            if (Array.isArray(item[0])) {
                if ((angle > item[0][0] && angle < item[0][1]) || (angle > item[1][0] && angle < item[1][1])) {
                    currentIndex = i;
                    break;
                }
            }
            else {
                if (angle > item[0] && angle < item[1]) {
                    currentIndex = i;
                    break;
                }
            }
        }
        return currentIndex;
    }
    return currentIndex;
}

/**
 *
 * 判断饼图当前touches对象是否在画布之内
 *
 * @param {*} currentPoints event.touches对象
 * @param {*} pieData series计算节点
 * @return {boolean} 点击点是否在画布之内
 */
function isInExactPieChartArea(currentPoints, pieData) {
    const {center, diameter, innerDiameter} = pieData;
    const distance = Math.sqrt(Math.pow(Math.abs(center.x - currentPoints.x), 2)
        + Math.pow(Math.abs(center.y - currentPoints.y), 2));
    if (distance >= (innerDiameter / 2) && distance <= (diameter / 2)) {
        return true;
    }
    return;
}


/**
 *
 * 对柱图数据浅cpoy
 *
 * @param {*} points [{value: 42, height: 280.56, x: 68, y: 91}]
 * @param {*} eachSpacing 坐标点间隔
 * @param {*} columnLen 一个分类里数据总数
 * @param {*} index 当前index
 * @param {*} config 用户配置
 * @return {Object}
 */
export function fixColumnData(points, eachSpacing, columnLen, index, config) {
    const {
        xAxis: {
            type
        },
        styleConfig: {
            columnPadding
        }
    } = config;
    return points.map(item => {
        if (item === null) {
            return null;
        }
        const itemCopy = {
            ...item,
            width: Math.min((eachSpacing - 2 * columnPadding) / columnLen, 30)
        };
        if (type === 'value') {
            itemCopy.y += (index + 0.5 - (columnLen) / 2) * itemCopy.width;
        }
        else {
            itemCopy.x += (index + 0.5 - (columnLen) / 2) * itemCopy.width;
        }
        return itemCopy;
    });
}