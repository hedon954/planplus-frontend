/**
 * @file util
 * @author yuanzhen
 * @date 2020/08/05
 */

const toString = Object.prototype.toString;

export let utils = {
    toFixed(num, limit = 2) {
        if (this.isFloat(num)) {
            num = num.toFixed(limit);
        }
        return num;
    },
    isFloat(num) {
        return num % 1 !== 0;
    }
};

/**
 * Check the given value whether is plain object type
 *
 * @param {*} obj the value to check
 * @return {boolean}
 */
export function isPlainObject(obj) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    let proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto;
}

/**
 * Check the given value whether is object type except for null
 *
 * @param {*} v the value to check
 * @return {boolean}
 */
export function isObject(v) {
    return v && typeof v === 'object';
}

/**
 * 合并数组
 *
 * @param {*} series 源数据
 * @return {*} array 返回合并的数组
 */
export function combineData(series) {
    return series.map(item => item.data).flat();
}

/**
 *
 * 获取取值范围
 *
 * @param {Array.<number>} Array.<number> 粗略区间
 * @param {*} splitNumber 分割值
 * @return {Object}
 */
export function getDataRange([minData, maxData], splitNumber) {
    let span = maxData - minData;
    let interval = nice(span / splitNumber, true);
    let minRange = roundNumber(Math.floor(minData / interval) * interval);
    let maxRange = roundNumber(Math.ceil(maxData / interval) * interval);
    return {
        minRange,
        maxRange,
        interval,
        splitNumber: (maxRange - minRange) / interval
    };
}

/**
 *
 * 获取预估值
 *
 * @param {*} val 粗略区间
 * @return {number}
 */
function quantityExponent(val) {
    if (val === 0) {
        return 0;
    }
    let exp = Math.floor(Math.log(val) / Math.LN10);
    /**
     * exp is expected to be the rounded-down result of the base-10 log of val.
     * But due to the precision loss with Math.log(val), we need to restore it
     * using 10^exp to make sure we can get val back from exp. #11249
     */
    if (val / Math.pow(10, exp) >= 10) {
        exp++;
    }
    return exp;
}

/**
 *
 * 获取区间值
 *
 * @param {*} val 粗略区间
 * @param {*} round 坐标轴能否到达最高点
 * @return {number}
 */
function nice(val, round) {
    let exponent = quantityExponent(val);
    let exp10 = Math.pow(10, exponent);
    let f = val / exp10; // 1 <= f < 10
    let nf;
    if (round) {
        if (f < 1.5) {
            nf = 1;
        } else if (f < 2.5) {
            nf = 2;
        } else if (f < 4) {
            nf = 3;
        } else if (f < 7) {
            nf = 5;
        } else {
            nf = 10;
        }
    } else {
        if (f < 1) {
            nf = 1;
        } else if (f < 2) {
            nf = 2;
        } else if (f < 3) {
            nf = 3;
        } else if (f < 5) {
            nf = 5;
        } else {
            nf = 10;
        }
    }
    val = nf * exp10;
    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}

/**
 *
 * 获取fixed值
 *
 * @param {*} x 输入值
 * @param {*} precision 精度
 * @param {*} returnStr 是否字符串
 * @return {*}
 */
function roundNumber(x, precision, returnStr) {
    if (precision == null) {
        precision = 10;
    }

    precision = Math.min(Math.max(0, precision), 20);
    x = (+x).toFixed(precision);
    return returnStr ? x : +x;
}

/**
 *
 * 获取文字宽度
 *
 * @param {*} text 文字
 * @param {*} fontSize 文字字体大小
 * @return {number}
 */
export function measureText(text, fontSize = 10) {
    text = String(text).split('');
    let width = 0;
    text.forEach(function (item) {
        if (/[a-zA-Z]/.test(item)) {
            width += 7;
        } else if (/[0-9]/.test(item)) {
            width += 5.5;
        } else if (/\./.test(item)) {
            width += 2.7;
        } else if (/-/.test(item)) {
            width += 10;
        } else if (/[\u4e00-\u9fa5]/.test(item)) {
            width += 10;
        } else if (/\(|\)/.test(item)) {
            width += 3.73;
        } else if (/\s/.test(item)) {
            width += 2.5;
        } else if (/%/.test(item)) {
            width += 8;
        } else {
            width += 10;
        }
    });
    return (width * fontSize) / 10;
}

/**
 *
 * 获取动画时长
 *
 * @param {*} animation 是否有动画
 * @return {number}
 */
export function getDuration(animation) {
    return animation
        ? !typeof animation === 'boolean' // 如果不是boolean类型
            ? !isNaN(+animation) // 是否不是 NaN
                ? isFinite(+animation) // 是否不是 Infinite
                    ? +animation
                    : 0
                : 0
            : 1000
        : 0;
}

/**
 *
 * 画圆角矩形
 *
 * @param {CanvasContext} ctx canvas上下文
 * @param {Object} opt 参数
 * @param {number} opt.x 圆角矩形选区的左上角 x坐标
 * @param {number} opt.y 圆角矩形选区的左上角 y坐标
 * @param {number} opt.w 圆角矩形选区的宽度
 * @param {number} opt.h 圆角矩形选区的高度
 * @param {number} opt.r 圆角的半径
 * @param {string} opt.color 色值
 */
export function drawRoundRect(ctx, opt) {
    let {x, y, w, h, r, color} = opt;
    // 开始绘制
    ctx.beginPath();
    // 因为边缘描边存在锯齿，最好指定使用 transparent 填充
    // 这里是使用 fill 还是 stroke都可以，二选一即可
    ctx.setFillStyle(color);
    ctx.setStrokeStyle(color);
    // 左上角
    ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5);

    // border-top
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.lineTo(x + w, y + r);
    // 右上角
    ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2);
    // border-right
    ctx.lineTo(x + w, y + h - r);
    ctx.lineTo(x + w - r, y + h);
    // 右下角
    ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5);
    // border-bottom
    ctx.lineTo(x + r, y + h);
    ctx.lineTo(x, y + h - r);
    // 左下角
    ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI);
    // border-left
    ctx.lineTo(x, y + r);
    ctx.lineTo(x + r, y);
    ctx.closePath();
}
