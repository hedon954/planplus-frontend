/**
 * @file draw
 * @author weicheng
 * @date 2020/09/09
 */
import {measureText} from '../chart/util';

/**
 * svgContext
 *
 * @param {Object} vm swan
 */
class SwanSvgChart {
    constructor(vm) {
        this.swan = vm;
        this.svgList = [];
        this.tmpObj = {};
        this.styleObj = {};
        this._defaultStyle = {
            'font-size': 10,
            'stroke': '#000',
            'stroke-width': 1
        };
        this.styleObjStack = [];
        this.cacheObj = {};
        this.useStyleStack = 0;
        this.translateObj = {
            x: 0,
            y: 0
        };
        this.rotateVal = 0;
    }
    // 私有方法
    // 刷新所有数据
    _refresh() {
        this._refreshSVG();
        this._refreshStyle();
        this.swan.setData({
            svgRefresh: false
        }, () => {
            this.swan.setData({svgRefresh: true});
        });
    }

    // 刷新svg数据
    _refreshSVG() {
        this.svgList = [];
    }

    // 刷新临时数据
    _refreshTmpObj() {
        this.tmpObj = {};
    }

    // 刷新样式数据
    _refreshStyle() {
        this.styleObj = {};
    }

    // 刷新缓存数据
    _refreshCache() {
        this.cacheObj = {};
    }

    /**
     * 合并svg数据
     *
     * @param {Object} newObj 当前数据
     * @param {Object} oldObj 之前数据
     * @return {Object} object 新数据
     */
    _mergeSVGData(newObj, oldObj) {
        return newObj.concat(oldObj);
    }

    /**
     * 合并缓存svg数据
     *
     * @return {Object} object 新数据
     */
    _mergeCacheSVGData() {
        const cacheKeys = Object.keys(this.cacheObj);
        let sumObj = {};
        while (cacheKeys.length) {
            sumObj = this._mergeSVGData(this.cacheObj[cacheKeys.pop()], sumObj);
        }
        return sumObj;
    }

    /**
     * 检测数据是否合规
     *
     * @param {string} type 类型
     * @param {Object} obj 对应对象
     */
    _checkAndModify(type, obj) {
        if (type === 'path' && obj.d) {
            let tmp = obj.d;
            let idx = tmp.indexOf('M');
            if (idx > -1) {
                obj.d = tmp.substr(idx);
            }
            else {
                delete obj.d;
            }
        }
    }

    /**
     * 添加视图数据
     *
     * @param {string} type 类型
     * @param {Object} obj 对应对象
     */
    _push(type, obj = {}) {
        if (type) {
            this._checkAndModify(type, obj);
            if (type === 'path' && !obj.d) {
                return;
            }
            this.svgList.push({
                tagName: type,
                ...obj
            });
        }
    }

    /**
     * 返回样式数据
     *
     * @return {Object} tmp 对应对象
     */
    _getStyleStackObj() {
        let tmp = {};
        this.styleObjStack.forEach(i => {
            tmp = {
                ...tmp,
                ...i
            };
        });
        return tmp;
    }

    /**
     * 获取样式数据
     *
     * @param {Array} names 想要获取的key
     * @return {Object} tmp 对应对象
     */
    _getStyle(names = ['fill', 'stroke-width', 'stroke']) {
        let tmpObj = {};
        names.forEach(i => {
            let tmpStyle = this.styleObj[i] || this._defaultStyle[i];
            tmpStyle && (tmpObj[i] = tmpStyle);
        });
        if (this.useStyleStack) {
            let stackObj = this._getStyleStackObj();
            let keys = Object.keys(stackObj);
            keys.forEach(i => {
                stackObj[i] && names.indexOf(i) > -1 && (tmpObj[i] = stackObj[i]);
            });
        }
        return tmpObj;
    }

    /**
     * 设置样式数据
     *
     * @param {string} key 想要获取的key
     * @param {string} val 对应对象
     */
    _setStyle(key, val) {
        if (this.useStyleStack) {
            this.styleObjStack[this.styleObjStack.length - 1][key] = val;
        }
        else {
            this.styleObj[key] = val;
        }
    }

    /**
     * 从对象中获取样式数据
     *
     * @param {Object} obj 获取对象
     * @return {string} sum string格式样式
     */
    _getStyleFromObj(obj) {
        let sum = '';
        let keys = Object.keys(obj);
        keys.forEach(item => {
            sum += `${item}:${obj[item]};`;
        });
        return sum;
    }

    /**
     * 获取svg数据
     *
     * @param {string} cacheName 获取缓存svg数据
     * @return {string} sum string格式样式
     */
    _getSVGData(cacheName) {
        this.cacheObj[cacheName] = this.svgList;
        return this._mergeCacheSVGData();
    }

    // 新样式空间压入样式栈
    save() {
        this.styleObjStack.push({});
        this.useStyleStack += 1;
    }

    // 弹出样式栈
    restore() {
        this.styleObjStack.pop();
        this.useStyleStack -= 1;
    }

    /**
     *
     * 设置路径颜色
     *
     * @param {string} val 变量
     */
    setStrokeStyle(val) {
        this._setStyle('stroke', val);
    }

    /**
     *
     * 设置线条宽度
     *
     * @param {string} val 变量
     */
    setLineWidth(val) {
        this._setStyle('stroke-width', val);
    }

    /**
     * 设置文字对齐
     *
     * @param {string} val enum:top|middle|bottom|alphabetic|hanging
     */
    setTextBaseline(val) {
        this._setStyle('vertical-align', val);
    }

    /**
     * 设置文字排版
     *
     * @param {string} val enum:right|center|left
     */
    setTextAlign(val) {
        switch (val) {
            case 'right':
                this._setStyle('transform', 'translateX(-100%)');
                break;
            case 'center':
                this._setStyle('transform', 'translateX(-50%)');
                break;
            case 'left':
                this._setStyle('transform', 'translateX(0%)');
                break;
        }
    }

    /**
     * 设置虚线样式
     *
     * @param {string} val 色值
     */
    setLineDash(val) {
        this._setStyle('stroke-dasharray', val);
    }

    /**
     * 设置文字大小
     *
     * @param {string} val size
     */
    setFontSize(val) {
        this._setStyle('font-size', val);
    }

    /**
     * 设置区域颜色
     *
     * @param {string} val 色值
     */
    setFillStyle(val) {
        this._setStyle('fill', val);
    }

    /**
     * 设置阴影 暂不支持
     *
     * @param {number} dx x坐标
     * @param {number} dy y坐标
     * @param {string} stdDeviation 色值
     * @param {string} color 色值
     */
    setShadow(dx, dy, stdDeviation, color) {
        // todo: by weicheng
        // this._setStyle('style', `filter:drop-shadow(${dx}, ${dy}, ${stdDeviation}, ${color})`);
    }

    // 开始新路径绘制
    beginPath() {
        this._refreshTmpObj();
        this._refreshStyle();
    }

    /**
     * 移动位置
     *
     * @param {number} x x坐标
     * @param {number} y y坐标
     */
    moveTo(x, y) {
        let {d = ''} = this.tmpObj;
        this.tmpObj.d = d + `M${x + this.translateObj.x} ${y + this.translateObj.y}`;
    }

    /**
     * 落笔后移动位置
     *
     * @param {number} x x坐标
     * @param {number} y y坐标
     */
    lineTo(x, y) {
        let {d = ''} = this.tmpObj;
        this.tmpObj.d = d + `L${x} ${y}`;
    }

    // 绘制轨迹
    stroke() {
        let tmpObj = this._getStyle(['stroke-width', 'stroke', 'stroke-dasharray']);
        this._push('path', {
            ...tmpObj,
            d: this.tmpObj.d
        });
    }

    // 闭合路径
    closePath() {
        let {d = ''} = this.tmpObj;
        this.tmpObj.d = d + 'Z';
    }

    // 区域填充
    fill() {
        let {d = ''} = this.tmpObj;
        if (d[d.length - 1] === 'Z') {
            this._push('path', Object.assign({}, this._getStyle(['fill', 'style']), this.tmpObj));
        }
    }

    /**
     * 绘制矩形
     *
     * @param {number} x 左上角x坐标
     * @param {number} y 左上角y坐标
     * @param {number} width 矩形宽度
     * @param {number} height 矩形高度
     */
    rect(x, y, width, height) {
        if (height < 0) {
            y = y + height;
            height = Math.abs(height);
        }
        if (width < 0) {
            x = x + width;
            width = Math.abs(width);
        }
        this.moveTo(x, y);
        this.lineTo(x, y + height);
        this.lineTo(x + width, y + height);
        this.lineTo(x + width, y);
        this.lineTo(x, y);
    }

    /**
     * 绘制文字
     *
     * @param {string} content 文字内容
     * @param {number} x 左上角x坐标
     * @param {number} y 左上角y坐标
     */
    fillText(content, x, y) {
        if (content !== undefined) {
            let styleObj = this._getStyle(['font-size', 'fill', 'transform', 'stroke', 'vertical-align']);
            styleObj.color = styleObj.fill || styleObj.stroke;
            styleObj.top = (y - styleObj['font-size'] + this.translateObj.y) + 'px';
            if (styleObj['vertical-align']) {
                styleObj.top = (y - (styleObj['font-size'] * 3 / 4) + this.translateObj.y) + 'px';
            }
            styleObj['font-size'] = styleObj['font-size'] + 'px';
            styleObj.left = (x + (this.translateObj.x || 0)) + 'px';
            styleObj.position = 'absolute';
            styleObj.transform = styleObj.transform;
            styleObj['z-index'] = '1';
            this._push('text', {
                content,
                style: this._getStyleFromObj(styleObj)
            });
        }
    }

    /**
     * 绘制圆弧
     *
     * @param {number} cx 圆心x坐标
     * @param {number} cy 圆心y坐标
     * @param {number} r 半径
     * @param {number} from 开始角度
     * @param {number} to 结束角度
     */
    arc(cx, cy, r, from, to) {
        let styleObj = this._getStyle(['fill', 'stroke']);
        cx = cx + this.translateObj.x;
        cy = cy + this.translateObj.y;
        if (to - from === Math.PI * 2) {
            this._push('circle', {
                r, cx, cy,
                fill: styleObj.fill || styleObj.stroke
            });
        }
        else {
            if (!this.tmpObj.d) {
                this.tmpObj.d = `M${cx} ${cy}`;
            }
            this.tmpObj.d += `L${cx + r * Math.cos(from + this.rotateVal)} ${cy + r * Math.sin(from + this.rotateVal)}
            A${r} ${r} 0 0 1 ${cx + r * Math.cos(to + this.rotateVal)} ${cy + r * Math.sin(to + this.rotateVal)}`;
        }
    }

    /**
     * 变换位置
     *
     * @param {number} x 变换后x坐标
     * @param {number} y 变换后y坐标
     */
    translate(x, y) {
        this.translateObj = {x, y};
    }

    /**
     * 旋转角度
     *
     * @param {number} val 旋转角度值
     */
    rotate(val) {
        this.rotateVal = val;
    }

    /**
     * 计算文字宽度
     *
     * @param {string} str 文字内容
     * @return {Object} 文字宽度
     */
    measureText(str) {
        const fontSize = this._getStyle(['font-size'])['font-size'];
        return {width: measureText(str, fontSize)};
    }

    /**
     * 绘制
     *
     * @param {string} cacheName 绘制内容
     */
    draw(cacheName = 'default') {
        this.swan.setData({svgData: this._getSVGData(cacheName)});
        this._refreshSVG();
    }
}

export default vm => new SwanSvgChart(vm);
